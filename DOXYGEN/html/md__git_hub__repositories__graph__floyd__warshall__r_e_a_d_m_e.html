<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-BR">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Graph-Floyd-Wasrhall: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Graph-Floyd-Wasrhall<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Trabalho da Disciplina de Algoritmos e Estrutura de Dados || - Gabriel Oliveira Alves</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Busca');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Carregando...</div>
<div class="SRStatus" id="Searching">Procurando...</div>
<div class="SRStatus" id="NoMatches">Nenhum resultado encontrado</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="justify"></div><div align="justify"><div align="center"></div></div><div align="justify"><div align="center"></div></div><h1><a class="anchor" id="autotoc_md11"></a>
Grafos: Algoritmo de Floyd-Warshall</h1>
<div align="justify"><div align="center"> </div></div><h4><a class="anchor" id="autotoc_md12"></a>
Trabalho Prático da Disciplina de Algoritmo e Estrutura de Dados II</h4>
<div align="justify"><div align="center"> </div></div><h4><a class="anchor" id="autotoc_md13"></a>
Gabriel Oliveira Alves</h4>
<div align="justify"><div align="center"> <img src="https://img.shields.io/badge/Linux-FCC624?style=for-the-badge&amp;logo=linux&amp;logoColor=black" alt="Linux" class="inline"/> <img src="https://img.shields.io/badge/mac%20os-000000?style=for-the-badge&amp;logo=apple&amp;logoColor=white" alt="MacOS" class="inline"/> <img src="https://img.shields.io/badge/VSCode-0078D4?style=for-the-badge&amp;logo=visual%20studio%20code&amp;logoColor=white" alt="Vscode" class="inline"/> <img src="https://img.shields.io/badge/C%2B%2B-00599C?style=for-the-badge&amp;logo=c%2B%2B&amp;logoColor=white" alt="C++" class="inline"/></div></div><div align="justify"><div align="center"></div></div><div align="justify"></div><h3><a class="anchor" id="autotoc_md14"></a>
Resumo</h3>
<div align="justify">Este repositório tem o intuito de apresentar de forma resumida a teória de grafos e implementar o algoritmo de Floyd-Warshall em um problema prático. A documentação refererente a este problema está presente em arquivo separado, sendo possível acessá-lo por meio do <em>linker</em> no último tópico.</div><div align="justify"></div><h2><a class="anchor" id="autotoc_md15"></a>
1 - O que é um grafo?</h2>
<div align="justify"> Grafos, são estruturas discretas que consistem em vértices e aresta que ligam estes vértices. Dentro da teória de grafos, temos os <em><b>Grafos Não-Orientados</b></em> e os <em><b>Grafos Orientados</b></em> (Digrafos ou grafos dirigidos), alguns possuem características únicas e são chamados de Grafos Especiais. Matemáticamente, um grafo pode ser representado por $G = (V,E)$, sendo $V$ um conjunto não vazio de vértices e $E$ o conjunto de arestas. No caso dos grafos orientados, cada aresta orientada está associada a um par ordenado de vértices. É dito que a aresta orientada associada ao par de vértices ${(u,v)}$ começa em $u$ e termina em $v$.</div><div align="justify"><ul>
<li>Dizemos que há um laço em um vértice quando, existe uma aresta que se liga a este mesmo vértice.</li>
<li>Arestas paralelas são quando duas arestes ligam o mesmo par de vértices de forma igual.</li>
</ul>
</div><div align="justify"><div align="center"></div></div><div align="justify"><div align="center"><img src="./assets/figura1.png" alt="Figura1" title="figura1.png" class="inline"/><br  />
 Figura 1 - Representação de Grafo Não-Orientado.</div></div><div align="justify"><div align="center"><img src="./assets/figura2.png" alt="Figura2" title="figura2.png" class="inline"/><br  />
 Figura 2 - Representação de Grafo Orientado com múltiplas arestas.</div></div><div align="justify"><div align="center"><img src="./assets/figura3.png" alt="Figura3" title="figura3.png" class="inline"/><br  />
 Figura 3 - Tabela de terminologia de alguns grafos.</div></div><div align="justify"><div align="center"></div></div><div align="justify"></div><h2><a class="anchor" id="autotoc_md16"></a>
2 - Implementação de Grafos</h2>
<div align="justify"> Em literatura, temos 3 estruturas que podem representar um grafo. <em><b>Lista de Adjacências</b></em>, <em><b>Matriz de Adjacências</b></em> e <em><b>Matriz de Incidências</b></em>, apenas as duas primeiras estruturas serão abordadas. Estas estruturas são utilizadas para representar grafos nas implementações por meio de código em linguagem de programação.</div><div align="justify"><blockquote class="doxtable">
<p >&zwj;Quando um grafo apresenta uma quantidade substancialmente grande de conexões e este grafo tem o seu conjunto de arestas $(|E|)$ proximo do conjunto de vértices ao quadrado $(|V^2|)$, dizemos que é um <b>Grafo Denso</b>. </p>
</blockquote>
<blockquote class="doxtable">
<p >&zwj;Quando o conjunto de arestas $(|E|)$ apresenta uma quantidade substancialmente menor que o conjunto de vértices ao quadrado $(|V^2|)$, dizemos que este é uma <b>Grafo Esparso</b>. </p>
</blockquote>
</div><h3><a class="anchor" id="autotoc_md17"></a>
2.1 - Lista de Adjacências</h3>
<div align="justify"> A representação de lista de adjacências de um grafo $G = (V , E )$ consiste em um arranjo (vetor ou lista dinâmica) de Adj. de $|V|$ listas, uma para cada vértice em $V$. Logo, para cada $u ∈ V$, a lista de adjacência Adj[$u$] contém todos os vértices $v$ que definem uma aresta $(u, v ) ∈ E$.</div><div align="justify"><div align="center"></div></div><div align="justify"><div align="center"><img src="./assets/listGNO.png" alt="lista_Grafo_NO" class="inline"/><br  />
 Figura 4 - Lista de Adjacências em grafo não-orientado.</div></div><div align="justify"><div align="center"><img src="./assets/listGO.png" alt="lista_Grafo_O" class="inline"/><br  />
 Figura 4 - Lista de Adjacências em grafo orientado. </div></div><div align="justify">De acordo com a literatura de referência, o custo do gasto de memória é dado por $\mathcal{O}(V+E)$. É indicada para <em><b>grafos esparsos</b></em> e não representa arestas múltiplas.</div><div align="justify"></div><h3><a class="anchor" id="autotoc_md18"></a>
2.2 - Matriz de Adjacências</h3>
<div align="justify"> A representação da matriz de adjacências $A_G$ de $G = (V,E)$ é a matriz zero-um (binária) (n,n), com 1 como seu elemento $(i,j)$ quando $v_i$ e $v_j$ forem adjacêntes e 0 como seu elemento $(i,j)$ quando eles não forem. Em outras palavras, se sua matriz de adjacência é , então:</div><div align="justify"><div align="right"></div></div><div align="justify"><div align="right">$$ a_{ij} = \begin{cases} 1 &amp; \text{ se } {(v_i,v_j) \in G}\ 0 &amp; \text{ se } {(v_i,v_j) \notin G} \end{cases}\ $$</div></div><div align="justify"><div align="right">Equação 1 </div></div><div align="justify"><div align="center"></div></div><div align="justify"><div align="center"><img src="./assets/matriz_GNO.png" alt="matriz_GNO" class="inline"/><br  />
 Figura 5 - Matriz de adjacências em grafo não-orientado.</div></div><div align="justify"><div align="center"><img src="./assets/matriz_GO.png" alt="matriz_GO" class="inline"/><br  />
 Figura 6 - Matriz de adjacências em grafo orientado.</div></div><div align="justify"><div align="center"></div></div><div align="justify">A matriz de adjacências facilita a pesquisa de arestas e por isso é uma ótima opção para <em><b>grafos densos</b></em>. Consegue representar arestas múltiplas, mas o seu custo de gasto de memória é na ordem de $\mathcal{O}(V^2)$.</div><div align="justify"><blockquote class="doxtable">
<p >&zwj;Ambas as estruturas apresentadas, podem representar <b>Grafos Ponderados</b>. </p>
</blockquote>
<b>Grafos Ponderados</b>, são grafos em que as arestas que conectam os vértices, possuem pesos - ou valores.</div><div align="justify"><blockquote class="doxtable">
<p >&zwj;Matriz de adjacências que não possuem laços, têm os elementos de sua <em>diagonal principal</em> iguais a zero. </p>
</blockquote>
</div><div align="justify"></div><h2><a class="anchor" id="autotoc_md19"></a>
3 - Algoritmo de Floyd-Warshall</h2>
<div align="justify"> O algoritmo <b>Floyd-Warshall</b> é responsável por encontrar o caminho mínimo ("caminho mais curto") entre todos os pares de vértices de um grafo. Este grafo deve ser <b>orientado</b> e <b>ponderado</b>.</div><div align="justify"><ul>
<li>Para explicar como o <b>Floyd-Warshall</b> funciona, antes deve-se ter o conhecimento de que as arestas podem ter valor (peso) negativo, entretanto,não poderá haver nenhum ciclo negativo - Caminho circular com todas as arestas com pesos negativos.</li>
</ul>
</div><div align="justify">Conforme as literaturas de referência, o algoritmo de <b>Floyd-Warshall</b>, recebe como entrada uma matriz de adjacências $A_G$ que representa um grafo $G = (V,E)$ de acordo com a definição dada no primeiro parágrafo deste tópico. Supondo que a matriz de adjacências da entrada, esteja preenchida corretamente no formato dado pela equação:</div><div align="justify"><div align="right"></div></div><div align="justify"><div align="right">$$ a_{ij} = \begin{cases} p &amp; \text{ se } {(v_i,v_j) \in G}\ \infty &amp; \text{ se } {(v_i,v_j) \notin G} \end{cases}\text{; Sendo p, o peso da aresta.} $$</div></div><div align="justify"><div align="right">Equação 2 </div></div><div align="justify">Conseguiremos aplicar o algoritmo recursivo, exemplo de programação dinâmica, afim de encontrar o menor caminho entre um par de vértices. Isso será feito com a ajuda de um vértice intermediário $k$ pertecente à um subconjunto de vértices $K \in |V|$.<ul>
<li>Para qualquer par de vértices $(i,j)$ em $V$, considere todos os caminhos de $i$ a $j$ cujos vértices intermédios pertencem ao subconjunto $K$, e $p$ como o caminho mais curto de todos eles.</li>
<li>O Algoritmo se baseia em explorar a relação entre o caminho $p$ e todos os caminhos mais curtos de $i$ a $j$ com todos os vértices intermédios de $K$ $(k...k-1)$.</li>
<li>A verificação dessa relação no algoritmo dependerá de $k$ ser ou não um vértice intermédio do caminho de $p$.</li>
</ul>
</div><div align="justify">O pseudocódigo abaixo utiliza-se duas matrizes de adjacências: A matriz de distâncias <code>m_dist</code> preenchida conforme a Equação 1 e a matriz de caminhos predecessores <code>m_pred</code> inicializada com valores nulos. <br  />
</div><div align="justify"><div class="fragment"><div class="line">// Sendo n o tamanho do conjunto de vértices do grafo G, temos:</div>
<div class="line"> </div>
<div class="line">FLOYD-WARSHALL(Matriz m_dist(n,n), matriz m_pred(n,n))</div>
<div class="line">    PARA K de 1 à n:</div>
<div class="line">        PARA i de 1 à n:</div>
<div class="line">            PARA j de 1 à n:</div>
<div class="line"> </div>
<div class="line">                Se m_dist[i,j] &gt; m_dist[i,k] + m_dist[k,j] ENTÃO:</div>
<div class="line">                    </div>
<div class="line">                    m_dist[i,j] = dist[i,k] + dist[k,j]</div>
<div class="line">                    m_pred[i,j] = m_pred[k,j] // salva o índice do vértice que um caminho para m_dist[i,j]</div>
<div class="line">                </div>
<div class="line">                Fim-Se</div>
<div class="line"> </div>
<div class="line">            FIM-PARA</div>
<div class="line">        FIM-PARA</div>
<div class="line">    FIM-PARA</div>
<div class="line">FIM-FUNÇÃO</div>
</div><!-- fragment --> </div><div align="justify"> Pseudocódigo Algoritmo de Floyd-Warshall</div><div align="justify"></div><div align="justify"><blockquote class="doxtable">
<p >&zwj;A complexidade do algoritmo de Floyd-Warshall, de acordo com a literatura é $\mathcal{O}(V^3)$. </p>
</blockquote>
O algoritmo de Floyd-Warshall, a título de curiosidade, pode ser um excelente exemplo de Programação Dinâmica. Por meio de uma fórmula matemática, descrita na <em>secção 25.2</em> do livro de referência Algoritmos - H.Cormen $^{[1]}$, é possível implementá-lo recursivamente.</div><div align="justify"></div><h2><a class="anchor" id="autotoc_md20"></a>
4 - Considerações Finais</h2>
<div align="justify"> </div><h3><a class="anchor" id="autotoc_md21"></a>
4.1 - Limitações do Algoritmo</h3>
<div align="justify"> O algoritmo de Floyd-Warshall implementado neste repositório segue a documentação acima. Ou seja, foi implementado com <b>Matriz de Adjacências</b>. Contudo, seria possível modificar o algoritmo para utilizar <b>Lista de Adjacências</b> - dessa forma, o custo em gasto de memória, ficaria menor -, visto que, o grafo gerado no problema prático é uma grafo esparso.</div><div align="justify"></div><h3><a class="anchor" id="autotoc_md22"></a>
4.2 - O problema prático</h3>
<div align="justify"> O problema prático consiste em encontrar o menor caminho - ou rota - para atender 3 clientes distintos, com cada cliente em um bairro diferente da cidade. Para isso, será utilizado o algoritmo de Floyd-Warshall, uma vez que, seu retorno é uma <b>Árvore Geradora Mínima</b> representada por uma matriz de adjacência. Por meio disso, é possível encontrar o menor caminho para qualquer par de vértices.</div><div align="justify">Os detalhes restantes sobre o problema prático e como o código foi implementado, se encontra em /Users/gabriel/Desktop/GitHub <a class="el" href="_d_o_c_u_m_e_n_t_a_t_i_o_n_8md.html">Repositories/Graph-Floyd-Warshall/DOCUMENTATION.md</a> "DOCUMENTATION.md".</div><div align="justify"></div><h2><a class="anchor" id="autotoc_md23"></a>
5 - Referências</h2>
<div align="justify"> [1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. Algoritmos: Teoria e Prática. 3ª edição. Elsevier, 2012</div><div align="justify">[2] Michel Pires - Repositório GitHub, @mpiress: graph - link: <a href="https://github.com/mpiress/graph">https://github.com/mpiress/graph</a>. Acessado em 21 de Novembro de 2022.</div><div align="justify"></div><h2><a class="anchor" id="autotoc_md24"></a>
6 - Compilação e Execução</h2>
<div align="justify"> Para compiplar e executar o algoritmo, este repositório deve ser <em><b>clonado</b></em>. Depois, acessar a pasta <code>code</code> de caminho **<code>Graph-Floyd-Warshall/code</code>** e Executar os comandos abaixo conforme suas funções.</div><div align="justify"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Comando   </th><th class="markdownTableHeadNone">Função    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>make clean</code>   </td><td class="markdownTableBodyNone">Apaga a última compilação realizada contida na pasta build    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>make</code>   </td><td class="markdownTableBodyNone">Executa a compilação do programa utilizando o gcc, e o resultado vai para a pasta build    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>make run</code>   </td><td class="markdownTableBodyNone">Executa o programa da pasta build após a realização da compilação   </td></tr>
</table>
</div><div align="justify"></div><h3><a class="anchor" id="autotoc_md25"></a>
*Documentação Doxygen</h3>
<div align="justify"> A documentação gerada pelo Doxygen se encontra na pasta Doxygen.<ul>
<li>Na pasta html, basta abrir o arquivo <code>index.html</code> em qualquer navegador web.</li>
<li>Há também o PDF gerado por meio do Latex do Doxygen.</li>
</ul>
</div><div align="justify"></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Gerado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
